#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#       parse.c
#       plot.c
#       scanner.c
#       standard.c
#       term.c
#       util.c
#       version.c
# This archive created: Mon Nov 17 18:12:40 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'parse.c'" '(6308 characters)'
if test -f 'parse.c'
then
        echo shar: will not over-write existing file "'parse.c'"
else
cat << \SHAR_EOF > 'parse.c'
/*
 *
 *    G N U P L O T  --  parse.c
 *
 *  Copyright (C) 1986 Colin Kelley, Thomas Williams
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <stdio.h>
#include <setjmp.h>
#include <signal.h>
#include <errno.h>
#include "plot.h"

extern BOOLEAN undefined;

#ifndef vms
extern int errno;
#endif

extern int next_function,c_function /* next available space in udft */;
extern int num_tokens,c_token;
extern struct lexical_unit token[];
extern char dummy_var[];
extern struct at_type *curr_at;

struct value *pop(),*integer(),*complex();

static struct at_type temp_at;
static jmp_buf fpe_env;

#define dummy (struct value *) 0

fpe()
{
        (void) signal(SIGFPE, fpe);
        undefined = TRUE;
        longjmp(fpe_env, TRUE);
}

evaluate_at(at,valptr)
struct at_type *at;
struct value *valptr;
{
        undefined = FALSE;
        errno = 0;
        reset_stack();
        if (setjmp(fpe_env))
                return;                         /* just bail out */
        (void) signal(SIGFPE, fpe);     /* catch core dumps on FPEs */

        execute_at(at);

        (void) signal(SIGFPE, SIG_DFL);

        if (errno == EDOM || errno == ERANGE) {
                undefined = TRUE;
        } else {
                (void) pop(valptr);
                check_stack();
        }
}


struct value *
const_express(valptr)
struct value *valptr;
{
register int tkn = c_token;
        if (END_OF_COMMAND)
                int_error("constant expression required",c_token);
        build_at(&temp_at);     /* make a temporary action table */
        evaluate_at(&temp_at,valptr);   /* run it and send answer back */
        if (undefined) {
                int_error("undefined value",tkn);
        }
        return(valptr);
}


build_at(at)    /* build full expressions */
struct at_type *at;
{
        curr_at = at;           /* set global variable */
        curr_at->count = 0;             /* reset action table !!! */
        express();
}


express()  /* full expressions */
{
        xterm();
        xterms();
}

xterm()  /* NEW!  ? : expressions */
{
        aterm();
        aterms();
}


aterm()
{
        bterm();
        bterms();
}


bterm()
{
        cterm();
        cterms();
}


cterm()
{
        dterm();
        dterms();
}


dterm()
{
        eterm();
        eterms();
}


eterm()
{
        fterm();
        fterms();
}


fterm()
{
        gterm();
        gterms();
}


gterm()
{
        hterm();
        hterms();
}


hterm()
{
        unary(); /* - things */
        iterms(); /* * / % */
}


factor()
{
register int value;
struct value a, real_value;

        if (equals(c_token,"(")) {
                c_token++;
                express();
                if (!equals(c_token,")"))
                        int_error("')' expected",c_token);
                c_token++;
        }
        else if (isnumber(c_token)) {
                convert(&real_value,c_token);
                c_token++;
                add_action(PUSHC, &real_value);
        }
        else if (isletter(c_token)) {
                if ((c_token+1 < num_tokens)  && equals(c_token+1,"(")) {
                value = standard(c_token);
                        if (value) {    /* it's a standard function */
                                c_token += 2;
                                express();
                                if (!equals(c_token,")"))
                                        int_error("')' expected",c_token);
                                c_token++;
                                add_action(value,dummy);
                        }
                        else {
                                value = user_defined(c_token);
                                c_token += 2;
                                express();
                                if (!equals(c_token,")"))
                                        int_error("')' expected",c_token);
                                c_token++;
                                add_action(CALL,integer(&a,value));
                        }
                }
                else {
                        if (equals(c_token,dummy_var)) {
                                value = c_function;
                                c_token++;
                                add_action(PUSHD,integer(&a,value));
                        }
                        else {
                                value = add_value(c_token);
                                c_token++;
                                add_action(PUSH,integer(&a,value));
                        }
                }
        } /* end if letter */
        else
                int_error("invalid expression ",c_token);

        /* add action code for ** operator */
        if (equals(c_token,"**")) {
                        c_token++;
                        unary();
                        add_action(POWER,dummy);
        }
}



xterms()
{  /* create action code for ? : expressions */

        while (equals(c_token,"?")) {
                c_token++;
                express();
                if (!equals(c_token,":"))
                        int_error("expecting ':'",c_token);
                c_token++;
                express();
                add_action(TERNIARY,dummy);
        }
}


aterms()
{  /* create action codes for || operator */

        while (equals(c_token,"||")) {
                c_token++;
                aterm();
                add_action(LOR,dummy);
        }
}


bterms()
{ /* create action code for && operator */

        while (equals(c_token,"&&")) {
                c_token++;
                bterm();
                add_action(LAND,dummy);
        }
}


cterms()
{ /* create action code for | operator */

        while (equals(c_token,"|")) {
                c_token++;
                cterm();
                add_action(BOR,dummy);
        }
}


dterms()
{ /* create action code for ^ operator */

        while (equals(c_token,"^")) {
                c_token++;
                dterm();
                add_action(XOR,dummy);
        }
}


eterms()
{ /* create action code for & operator */

        while (equals(c_token,"&")) {
                c_token++;
                eterm();
                add_action(BAND,dummy);
        }
}


fterms()
{ /* create action codes for == and != operators */

        while (TRUE) {
                if (equals(c_token,"==")) {
                        c_token++;
                        fterm();
                        add_action(EQ,dummy);
                }
                else if (equals(c_token,"!=")) {
                        c_token++;
                        fterm();
                        add_action(NE,dummy);
                }
                else break;
        }
}


gterms()
{ /* create action code for < > >= or <= operators */

        while (TRUE) {
                /* I hate "else if" statements */
                if (equals(c_token,">")) {
                        c_token++;
                        gterm();
                        add_action(GT,dummy);
                }
                else if (equals(c_token,"<")) {
                        c_token++;
                        gterm();
                        add_action(LT,dummy);
                }               
                else if (equals(c_token,">=")) {
                        c_token++;
                        gterm();
                        add_action(GE,dummy);
                }
                else if (equals(c_token,"<=")) {
                        c_token++;
                        gterm();
                        add_action(LE,dummy);
                }
                else break;
        }

}



hterms()
{ /* create action codes for + and - operators */

        while (TRUE) {
                        if (equals(c_token,"+")) {
                                c_token++;
                                hterm();
                                add_action(PLUS,dummy);
                        }
                        else if (equals(c_token,"-")) {
                                c_token++;
                                hterm();
                                add_action(MINUS,dummy);
                        }
                        else break;
        }
}


iterms()
{ /* add action code for * / and % operators */

        while (TRUE) {
                        if (equals(c_token,"*")) {
                                c_token++;
                                unary();
                                add_action(MULT,dummy);
                        }
                        else if (equals(c_token,"/")) {
                                c_token++;
                                unary();
                                add_action(DIV,dummy);
                        }
                        else if (equals(c_token,"%")) {
                                c_token++;
                                unary();
                                add_action(MOD,dummy);
                        }
                        else break;
        }
}


unary()
{ /* add code for unary operators */
        if (equals(c_token,"!")) {
                c_token++;
                unary();
                add_action(LNOT,dummy);
        }
        else if (equals(c_token,"~")) {
                c_token++;
                unary();
                add_action(BNOT,dummy);
        }
        else if (equals(c_token,"-")) {
                c_token++;
                unary();
                add_action(UMINUS,dummy);
        }
        else
                factor();
}
SHAR_EOF
if test 6308 -ne "`wc -c < 'parse.c'`"
then
        echo shar: error transmitting "'parse.c'" '(should have been 6308 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'plot.c'" '(3628 characters)'
if test -f 'plot.c'
then
        echo shar: will not over-write existing file "'plot.c'"
else
cat << \SHAR_EOF > 'plot.c'
/*
 *
 *    G N U P L O T  --  plot.c
 *
 *  Copyright (C) 1986 Thomas Williams, Colin Kelley
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <stdio.h>
#include <setjmp.h>
#include <signal.h>
#include "plot.h"

extern FILE *outfile;
extern int term;

#ifndef STDOUT
#define STDOUT 1
#endif

jmp_buf env;

struct value stack[STACK_DEPTH];

struct lexical_unit token[MAX_TOKENS];

struct value *integer(),*complex();


extern struct termentry term_tbl[];

extern f_push(),f_pushc(),f_pushd(),f_call(),f_terniary(),f_lnot(),f_bnot(),
        f_uminus(),f_lor(),f_land(),f_bor(),f_xor(),f_band(),f_eq(),f_ne(),
        f_gt(),f_lt(),f_ge(),f_le(),f_plus(),f_minus(),f_mult(),f_div(),
        f_mod(),f_power();

extern f_real(),f_imag(),f_arg(),f_conjg(),f_sin(),f_cos(),f_tan(),f_asin(),
        f_acos(),f_atan(),f_sinh(),f_cosh(),f_tanh(),f_int(),f_abs(),f_sgn(),
        f_sqrt(),f_exp(),f_log10(),f_log(),f_besj0(),f_besj1(),f_besy0(),f_besy1(),
        f_floor(),f_ceil();


struct ft_entry ft[] = {        /* built-in function table */

/* internal functions: */
        {"push", f_push},       {"pushc", f_pushc},     {"pushd", f_pushd},
        {"call", f_call},       {"?:", f_terniary},     {"lnot", f_lnot},
        {"bnot", f_bnot},       {"uminus", f_uminus},   {"lor", f_lor},
        {"land", f_land},       {"bor", f_bor},         {"xor", f_xor},
        {"band", f_band},       {"eq", f_eq},           {"ne", f_ne},
        {"gt", f_gt},           {"lt", f_lt},           {"ge", f_ge},
        {"le", f_le},           {"plus", f_plus},       {"minus", f_minus},
        {"mult", f_mult},       {"div", f_div},         {"mod", f_mod},
        {"power", f_power},

/* standard functions: */
        {"real", f_real},       {"imag", f_imag},       {"arg", f_arg},
        {"conjg", f_conjg}, {"sin", f_sin},             {"cos", f_cos},
        {"tan", f_tan},         {"asin", f_asin},       {"acos", f_acos},
        {"atan", f_atan},       {"sinh", f_sinh},       {"cosh", f_cosh},
        {"tanh", f_tanh},       {"int", f_int},         {"abs", f_abs},
        {"sgn", f_sgn},         {"sqrt", f_sqrt},       {"exp", f_exp},
        {"log10", f_log10},     {"log", f_log},         {"besj0", f_besj0},
        {"besj1", f_besj1},     {"besy0", f_besy0},     {"besy1", f_besy1},
        {"floor", f_floor},     {"ceil", f_ceil},       {NULL, NULL}
};

struct udft_entry udft[MAX_UDFS+1];

struct vt_entry vt[MAX_VALUES] = {
        {"pi"},                 {"xmin"},               {"xmax"},
        {"ymin"},               {"ymax"},               {"autoscale"}
};


#ifdef vms

#define HOME "sys$login:"

#else /* vms */
#ifdef MSDOS

#define HOME "GNUPLOT"

#else /* MSDOS */

#define HOME "HOME"

#endif /* MSDOS */
#endif /* vms */

#ifdef unix
#define PLOTRC ".gnuplot"
#else
#define PLOTRC "gnuplot.ini"
#endif

interrupt()
{
        (void) signal(SIGINT, interrupt);
        (void) signal(SIGFPE, SIG_DFL); /* turn off FPE trapping */
        if (term)
                (*term_tbl[term].text)();       /* hopefully reset text mode */
        (void) fflush(outfile);
        (void) putc('\n',stderr);
        longjmp(env, TRUE);             /* return to prompt */
}


main()
{
char *getenv(),*strcat(),*strcpy();
FILE *plotrc;
static char home[sizeof(PLOTRC)+40];

        setbuf(stderr,NULL);
        outfile = fdopen(dup(STDOUT),"w");
        (void) complex(&vt[(int)C_PI].vt_value, Pi, 0.0);

        pointmem(SAMPLES);              /* malloc memory to keep plot points in */

        if (!setjmp(env)) {             /* come back here from printerror() */
                (void) signal(SIGINT, interrupt);       /* go there on interrupt char */
                if (!(plotrc = (fopen(PLOTRC,"r")))) {
#ifdef vms
                        (void) strcpy(home,HOME);
                        plotrc = fopen(strcat(home,PLOTRC),"r");
#else
                        (void) strcat(strcpy(home,getenv(HOME)),"/");
                        plotrc = fopen(strcat(home,PLOTRC),"r");
#endif /* vms */
                }
                if (plotrc)
                        load_file(plotrc);
        }

loop:   com_line();
        goto loop;
}
SHAR_EOF
if test 3628 -ne "`wc -c < 'plot.c'`"
then
        echo shar: error transmitting "'plot.c'" '(should have been 3628 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'scanner.c'" '(6979 characters)'
if test -f 'scanner.c'
then
        echo shar: will not over-write existing file "'scanner.c'"
else
cat << \SHAR_EOF > 'scanner.c'
/*
 *
 *    G N U P L O T  --  scanner.c
 *
 *  Copyright (C) 1986 Colin Kelley, Thomas Williams
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <stdio.h>
#include <ctype.h>
#include "plot.h"

extern BOOLEAN screen_ok;

#ifdef vms

#include stdio
#include descrip
#include errno

#define MAILBOX "PLOT$MAILBOX"
#define pclose(f) fclose(f)

#endif /* vms */


#ifndef STDOUT
#define STDOUT 1
#endif

#define LBRACE '{'
#define RBRACE '}'

#define APPEND_TOKEN {token[t_num].length++; current++;}

#define SCAN_IDENTIFIER while (isalpha(expression[current + 1]) ||\
                               isdigit(expression[current + 1]))\
                                APPEND_TOKEN

extern struct lexical_unit token[MAX_TOKENS];

static int t_num;       /* number of token I'm working on */

char *strcat(), *strcpy();

/*
 * scanner() breaks expression[] into lexical units, storing them in token[].
 *   The total number of tokens found is returned as the function value.
 *   Scanning will stop when '\0' is found in expression[], or when token[]
 *     is full.
 *
 *       Scanning is performed by following rules:
 *
 *              Current char    token should contain
 *     -------------    -----------------------
 *              1.  alpha               all following alpha-numerics
 *              2.  digit               0 or more following digits, 0 or 1 decimal point,
 *                                                0 or more digits, 0 or 1 'e' or 'E',
 *                                                0 or more digits.
 *              3.  ^,+,-,/             only current char
 *                  %,~,(,)
 *                  [,],;,:,
 *                  ?,comma
 *              4.  &,|,=,*             current char; also next if next is same
 *              5.  !,<,>               current char; also next if next is =
 *              6.  ", '                all chars up until matching quote
 *
 *              white space between tokens is ignored
 */
scanner(expression)
char expression[];
{
register int current;   /* index of current char in expression[] */
register int quote;
char brace;

        for (current = t_num = 0;
            t_num < MAX_TOKENS && expression[current] != '\0';
            current++) {
again:
                if (isspace(expression[current]))
                        continue;                                               /* skip the whitespace */
                token[t_num].start_index = current;
                token[t_num].length = 1;
                token[t_num].is_token = TRUE;   /* to start with...*/

                if (expression[current] == '`') {
                        substitute(&expression[current],MAX_LINE_LEN - current);
                        goto again;
                }
                if (isalpha(expression[current])) {
                        SCAN_IDENTIFIER;
                } else if (isdigit(expression[current]) ||
                           expression[current] == '.') {
                        token[t_num].is_token = FALSE;
                        token[t_num].length = get_num(&expression[current]);
                        current += (token[t_num].length - 1);
                } else if (expression[current] == LBRACE) {
                        token[t_num].is_token = FALSE;
                        token[t_num].l_val.type = CMPLX;
                        if ((sscanf(&expression[++current],"%lf , %lf %c",
                                &token[t_num].l_val.v.cmplx_val.real,
                                &token[t_num].l_val.v.cmplx_val.imag,
                                &brace) != 3) || (brace != RBRACE))
                                        int_error("invalid complex constant",t_num);
                        token[t_num].length += 2;
                        while (expression[++current] != RBRACE) {
                                token[t_num].length++;
                                if (expression[current] == '\0')
                                        int_error("no matching '}'", t_num);
                        }
                } else if (expression[current] == '\'' || expression[current] == '\"') {
                        token[t_num].length++;
                        quote = expression[current];
                        while (expression[++current] != quote) {
                                if (expression[current] == '\0')
                                        int_error("unmatched quote",t_num);
                                token[t_num].length++;
                        }
                } else switch (expression[current]) {
                        case '^':
                        case '+':
                        case '-':
                        case '/':
                        case '%':
                        case '~':
                        case '(':
                        case ')':
                        case '[':
                        case ']':
                        case ';':
                        case ':':
                        case '?':
                        case ',':
                                break;
                        case '&':
                        case '|':
                        case '=':
                        case '*':
                                if (expression[current] ==
                                    expression[current + 1])
                                        APPEND_TOKEN;
                                break;
                        case '!':
                        case '<':
                        case '>':
                                if (expression[current + 1] == '=')
                                        APPEND_TOKEN;
                                break;
                        default:
                                int_error("invalid character",t_num);
                        }
                ++t_num;        /* next token if not white space */
        }

/* Now kludge an extra token which points to '\0' at end of expression[].
   This is useful so printerror() looks nice even if we've fallen off the
   line. */

                token[t_num].start_index = current;
                token[t_num].length = 0;
        return(t_num);
}


get_num(str)
char str[];
{
double atof();
register int count = 0;
long atol();
register long lval;

        token[t_num].is_token = FALSE;
        token[t_num].l_val.type = INT;          /* assume unless . or E found */
        while (isdigit(str[count]))
                count++;
        if (str[count] == '.') {
                token[t_num].l_val.type = CMPLX;
                while (isdigit(str[++count]))   /* swallow up digits until non-digit */
                        ;
                /* now str[count] is other than a digit */
        }
        if (str[count] == 'e' || str[count] == 'E') {
                token[t_num].l_val.type = CMPLX;
                if (str[++count] == '-')
                        count++;
                if (!isdigit(str[count])) {
                        token[t_num].start_index += count;
                        int_error("expecting exponent",t_num);
                }
                while (isdigit(str[++count]))
                        ;
        }
        if (token[t_num].l_val.type == INT) {
                lval = atol(str);
                if ((token[t_num].l_val.v.int_val = lval) != lval)
                        int_error("integer overflow; change to floating point",t_num);
        } else {
                token[t_num].l_val.v.cmplx_val.imag = 0.0;
                token[t_num].l_val.v.cmplx_val.real = atof(str);
        }
        return(count);
}


#ifdef MSDOS

substitute()
{
        int_error("substitution not supported by MS-DOS!",t_num);
}

#else /* MSDOS */

substitute(str,max)                     /* substitute output from ` ` */
char *str;
int max;
{
register char *last;
register int i,c;
register FILE *f;
FILE *popen();
static char pgm[MAX_LINE_LEN],output[MAX_LINE_LEN];

#ifdef vms
int chan;
static $DESCRIPTOR(pgmdsc,pgm);
static $DESCRIPTOR(lognamedsc,MAILBOX);
#endif /* vms */

        i = 0;
        last = str;
        while (*(++last) != '`') {
                if (*last == '\0')
                        int_error("unmatched `",t_num);
                pgm[i++] = *last;
        }
        pgm[i] = '\0';          /* end with null */
        max -= strlen(last);    /* max is now the max length of output sub. */

#ifdef vms
        pgmdsc.dsc$w_length = i;
        if (!((vaxc$errno = sys$crembx(0,&chan,0,0,0,0,&lognamedsc)) & 1))
                os_error("sys$crembx failed",NO_CARET);

        if (!((vaxc$errno = lib$spawn(&pgmdsc,0,&lognamedsc,&1)) & 1))
                os_error("lib$spawn failed",NO_CARET);

        if ((f = fopen(MAILBOX,"r")) == NULL)
                os_error("mailbox open failed",NO_CARET);
#else /* vms */
        if ((f = popen(pgm,"r")) == NULL)
                os_error("popen failed",NO_CARET);
#endif /* vms */

        i = 0;
        while ((c = getc(f)) != EOF) {
                output[i++] = ((c == '\n') ? ' ' : c);  /* newlines become blanks*/
                if (i == max) {
                        (void) pclose(f);
                        int_error("substitution overflow", t_num);
                }
        }
        (void) pclose(f);
        if (i + strlen(last) > max)
                int_error("substitution overflowed rest of line", t_num);
        (void) strcpy(output+i,last+1);         /* tack on rest of line to output */
        (void) strcpy(str,output);                              /* now replace ` ` with output */
        screen_ok = FALSE;
}
#endif /* MS-DOS */
SHAR_EOF
if test 6979 -ne "`wc -c < 'scanner.c'`"
then
        echo shar: error transmitting "'scanner.c'" '(should have been 6979 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'standard.c'" '(5457 characters)'
if test -f 'standard.c'
then
        echo shar: will not over-write existing file "'standard.c'"
else
cat << \SHAR_EOF > 'standard.c'
/*
 *
 *    G N U P L O T  --  header.c
 *
 *  Copyright (C) 1986 Thomas Williams, Colin Kelley
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <math.h>
#include <stdio.h>
#include "plot.h"

extern BOOLEAN undefined;

#ifdef vms
#include <errno.h>
#else
extern int errno;
#endif /* vms */


extern struct value stack[STACK_DEPTH];
extern int s_p;

struct value *pop(), *complex(), *integer();

double magnitude(), angle(), real(), imag();


f_real()
{
struct value a;
        push( complex(&a,real(pop(&a)), 0.0) );
}

f_imag()
{
struct value a;
        push( complex(&a,imag(pop(&a)), 0.0) );
}

f_arg()
{
struct value a;
        push( complex(&a,angle(pop(&a)), 0.0) );
}

f_conjg()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,real(&a),-imag(&a) ));
}

f_sin()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,sin(real(&a))*cosh(imag(&a)), cos(real(&a))*sinh(imag(&a))) );
}

f_cos()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,cos(real(&a))*cosh(imag(&a)), -sin(real(&a))*sinh(imag(&a))));
}

f_tan()
{
struct value a;
register double den;
        (void) pop(&a);
        den = cos(2*real(&a))+cosh(2*imag(&a));
        push( complex(&a,sin(2*real(&a))/den, sinh(2*imag(&a))/den) );
}

f_asin()
{
struct value a;
register double alpha, beta, x, y;
        (void) pop(&a);
        x = real(&a); y = imag(&a);
        if (y == 0.0) {
                if (fabs(x) > 1.0) {
                        undefined = TRUE;
                        push(complex(&a,0.0, 0.0));
                } else
                        push( complex(&a,asin(x),0.0) );
        } else {
                beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
                alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
                push( complex(&a,asin(beta), log(alpha + sqrt(alpha*alpha-1))) );
        }
}

f_acos()
{
struct value a;
register double alpha, beta, x, y;
        (void) pop(&a);
        x = real(&a); y = imag(&a);
        if (y == 0.0) {
                if (fabs(x) > 1.0) {
                        undefined = TRUE;
                        push(complex(&a,0.0, 0.0));
                } else
                        push( complex(&a,acos(x),0.0) );
        } else {
                alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
                beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
                push( complex(&a,acos(beta), log(alpha + sqrt(alpha*alpha-1))) );
        }
}

f_atan()
{
struct value a;
register double x, y;
        (void) pop(&a);
        x = real(&a); y = imag(&a);
        if (y == 0.0)
                push( complex(&a,atan(x), 0.0) );
        else if (x == 0.0 && fabs(y) == 1.0) {
                undefined = TRUE;
                push(complex(&a,0.0, 0.0));
        } else
                push( complex(&a,atan(2*x/(1-x*x-y*y)),
                        log((x*x+(y+1)*(y+1))/(x*x+(y-1)*(y-1)))/4) );
}

f_sinh()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,sinh(real(&a))*cos(imag(&a)), cosh(real(&a))*sin(imag(&a))) );
}

f_cosh()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,cosh(real(&a))*cos(imag(&a)), sinh(real(&a))*sin(imag(&a))) );
}

f_tanh()
{
struct value a;
register double den;
        (void) pop(&a);
        den = cosh(2*real(&a)) + cos(2*imag(&a));
        push( complex(&a,sinh(2*real(&a))/den, sin(2*imag(&a))/den) );
}

f_int()
{
struct value a;
        push( integer(&a,(int)real(pop(&a))) );
}


f_abs()
{
struct value a;
        (void) pop(&a);
        switch (a.type) {
                case INT:
                        push( integer(&a,abs(a.v.int_val)) );
                        break;
                case CMPLX:
                        push( complex(&a,magnitude(&a), 0.0) );
        }
}

f_sgn()
{
struct value a;
        (void) pop(&a);
        switch(a.type) {
                case INT:
                        push( integer(&a,(a.v.int_val > 0) ? 1 :
                                        (a.v.int_val < 0) ? -1 : 0) );
                        break;
                case CMPLX:
                        push( integer(&a,(a.v.cmplx_val.real > 0.0) ? 1 :
                                        (a.v.cmplx_val.real < 0.0) ? -1 : 0) );
                        break;
        }
}


f_sqrt()
{
struct value a;
        double mag, ang;
        (void) pop(&a);
        mag = sqrt(magnitude(&a));
        if ( (ang = angle(&a)) < 0.0)
                ang += 2*Pi;
        ang /= 2;
        push( complex(&a,mag*cos(ang), mag*sin(ang)) );
}


f_exp()
{
register double mag, ang;
struct value a;
        (void) pop(&a);
        mag = exp(real(&a));
        ang = imag(&a);
        push( complex(&a,mag*cos(ang), mag*sin(ang)) );
}


f_log10()
{
struct value a;
register double l10;;
        (void) pop(&a);
        l10 = log(10.0);        /***** replace with a constant! ******/
        push( complex(&a,log(magnitude(&a))/l10, angle(&a)/l10) );
}


f_log()
{
struct value a;
        (void) pop(&a);
        push( complex(&a,log(magnitude(&a)), angle(&a)) );
}

f_besj0()       /* j0(a) = sin(a)/a */
{
struct value a;
        a = top_of_stack;
        f_sin();
        push(&a);
        f_div();
}


f_besj1()       /* j1(a) = sin(a)/(a**2) - cos(a)/a */
{
struct value a;
        a = top_of_stack;
        f_sin();
        push(&a);
        push(&a);
        f_mult();
        f_div();
        push(&a);
        f_cos();
        push(&a);
        f_div();
        f_minus();
}


f_besy0()       /* y0(a) = -cos(a)/a */
{
struct value a;
        a = top_of_stack;
        f_cos();
        push(&a);
        f_div();
        f_uminus();
}


f_besy1()       /* y1(a) = -cos(a)/(a**2) - sin(a)/a */
{
struct value a;

        a = top_of_stack;
        f_cos();
        push(&a);
        push(&a);
        f_mult();
        f_div();
        push(&a);
        f_sin();
        push(&a);
        f_div();
        f_plus();
        f_uminus();
}


f_floor()
{
struct value a;

        (void) pop(&a);
        switch (a.type) {
                case INT:
                        push( integer(&a,(int)floor((double)a.v.int_val)));
                        break;
                case CMPLX:
                        push( complex(&a,floor(a.v.cmplx_val.real),
                                floor(a.v.cmplx_val.imag)) );
        }
}



f_ceil()
{
struct value a;

        (void) pop(&a);
        switch (a.type) {
                case INT:
                        push( integer(&a,(int)ceil((double)a.v.int_val)));
                        break;
                case CMPLX:
                        push( complex(&a,ceil(a.v.cmplx_val.real), ceil(a.v.cmplx_val.imag)) );
        }
}
SHAR_EOF
if test 5457 -ne "`wc -c < 'standard.c'`"
then
        echo shar: error transmitting "'standard.c'" '(should have been 5457 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'term.c'" '(17424 characters)'
if test -f 'term.c'
then
        echo shar: will not over-write existing file "'term.c'"
else
cat << \SHAR_EOF > 'term.c'
/*
 *
 *    G N U P L O T  --  term.c
 *
 *  Copyright (C) 1986 Colin Kelley, Thomas Williams
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <stdio.h>
#include "plot.h"

#define NICE_LINE               0
#define POINT_TYPES             6

extern FILE *outfile;
extern BOOLEAN term_init;
extern int term;

extern char input_line[];
extern struct lexical_unit token[];
extern struct termentry term_tbl[];

#ifdef PC
static int pattern[] = {0xffff, 0x0f0f, 0xffff, 0x3333, 0x3f3f};

#ifdef CORONA
char screen[65535];
#endif /* CORONA */

int mask;
static int graphics_on = FALSE;
int startx, starty;

#define EGA_XMAX 640
#define EGA_YMAX 350

#define EGA_XLAST (EGA_XMAX - 1)
#define EGA_YLAST (EGA_YMAX - 1)

#define EGA_VCHAR 14
#define EGA_HCHAR 8
#define EGA_VTIC 5
#define EGA_HTIC 5


#define CGA_XMAX 640
#define CGA_YMAX 200

#define CGA_XLAST (CGA_XMAX - 1)
#define CGA_YLAST (CGA_YMAX - 1)

#define CGA_VCHAR 8
#define CGA_HCHAR 8
#define CGA_VTIC 3
#define CGA_HTIC 3

#ifdef CORONA
#define COR_XMAX 640
#define COR_YMAX 325

#define COR_XLAST (COR_XMAX - 1)
#define COR_YLAST (COR_YMAX - 1)

#define COR_VCHAR 13
#define COR_HCHAR 8
#define COR_VTIC 4
#define COR_HTIC 4
#endif /* CORONA */
#endif /* PC */

/*
 * general point routine
 */
line_and_point(x,y,number)
int x,y,number;
{
        /* temporary(?) kludge to allow terminals with bad linetypes
                to make nice marks */

        (*term_tbl[term].linetype)(NICE_LINE);
        do_point(x,y,number);
}

do_point(x,y,number)
int x,y;
int number;
{
register struct termentry *t;
register int htic,vtic;

        number %= POINT_TYPES;
        t = &term_tbl[term];
        htic = (t->h_tic/2);    /* should be in term_tbl[] in later version */
        vtic = (t->v_tic/2);

        if ( x < t->h_tic || y < t->v_tic || x >= t->xmax-t->h_tic ||
                y >= t->ymax-t->v_tic )
                return;                         /* add clipping in later version !!! */

        switch(number) {
                case 0: /* do diamond */
                                (*t->move)(x-htic,y);
                                (*t->vector)(x,y-vtic);
                                (*t->vector)(x+htic,y);
                                (*t->vector)(x,y+vtic);
                                (*t->vector)(x-htic,y);
                                (*t->move)(x,y);
                                (*t->vector)(x,y);
                                break;
                case 1: /* do plus */
                                (*t->move)(x-htic,y);
                                (*t->vector)(x+htic,y);
                                (*t->move)(x,y-vtic);
                                (*t->vector)(x,y+vtic);
                                break;
                case 2: /* do box */
                                (*t->move)(x-htic,y-vtic);
                                (*t->vector)(x+htic,y-vtic);
                                (*t->vector)(x+htic,y+vtic);
                                (*t->vector)(x-htic,y+vtic);
                                (*t->vector)(x-htic,y-vtic);
                                (*t->move)(x,y);
                                (*t->vector)(x,y);
                                break;
                case 3: /* do X */
                                (*t->move)(x-htic,y-vtic);
                                (*t->vector)(x+htic,y+vtic);
                                (*t->move)(x-htic,y+vtic);
                                (*t->vector)(x+htic,y-vtic);
                                break;
                case 4: /* do triangle */
                                (*t->move)(x,y+(4*vtic/3));
                                (*t->vector)(x-(4*htic/3),y-(2*vtic/3));
                                (*t->vector)(x+(4*htic/3),y-(2*vtic/3));
                                (*t->vector)(x,y+(4*vtic/3));
                                (*t->move)(x,y);
                                (*t->vector)(x,y);
                                break;
                case 5: /* do star */
                                (*t->move)(x-htic,y);
                                (*t->vector)(x+htic,y);
                                (*t->move)(x,y-vtic);
                                (*t->vector)(x,y+vtic);
                                (*t->move)(x-htic,y-vtic);
                                (*t->vector)(x+htic,y+vtic);
                                (*t->move)(x-htic,y+vtic);
                                (*t->vector)(x+htic,y-vtic);
                                break;
        }
}



#define AED_XMAX 768
#define AED_YMAX 575

#define AED_XLAST (AED_XMAX - 1)
#define AED_YLAST (AED_YMAX - 1)

#define AED_VCHAR       13
#define AED_HCHAR       8
#define AED_VTIC        8
#define AED_HTIC        7




#define HP75_XMAX 6000
#define HP75_YMAX 6000

#define HP75_XLAST (HP75_XMAX - 1)
#define HP75_YLAST (HP75_XMAX - 1)

/* HP75_VCHAR, HP75_HCHAR  are not used */
#define HP75_VCHAR      (HP75_YMAX/20)
#define HP75_HCHAR      (HP75_XMAX/20)
#define HP75_VTIC       (HP75_YMAX/70)
#define HP75_HTIC       (HP75_XMAX/75)




#define REGISXMAX 800
#define REGISYMAX 440

#define REGISXLAST (REGISXMAX - 1)
#define REGISYLAST (REGISYMAX - 1)

#define REGISVCHAR              20
#define REGISHCHAR              8
#define REGISVTIC               8
#define REGISHTIC               6



#define QMS_XMAX 9000
#define QMS_YMAX 6000

#define QMS_XLAST (QMS_XMAX - 1)
#define QMS_YLAST (QMS_YMAX - 1)

#define QMS_VCHAR               120
#define QMS_HCHAR               75
#define QMS_VTIC                70
#define QMS_HTIC                70




#define TEK40XMAX 1024
#define TEK40YMAX 780

#define TEK40XLAST (TEK40XMAX - 1)
#define TEK40YLAST (TEK40YMAX - 1)

#define TEK40VCHAR      25
#define TEK40HCHAR              14
#define TEK40VTIC               11
#define TEK40HTIC               11




#ifdef UNIXPLOT

#define UP_XMAX 4096
#define UP_YMAX 4096

#define UP_XLAST (UP_XMAX - 1)
#define UP_YLAST (UP_YMAX - 1)

#define UP_VCHAR (UP_YMAX/30)
#define UP_HCHAR (UP_XMAX/72)   /* just a guess--no way to know this! */
#define UP_VTIC (UP_YMAX/80)
#define UP_HTIC (UP_XMAX/80)

#endif /* UNIXPLOT */



#define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry))

#ifdef PC

PC_lrput_text(row,str)
int row;
char str[];
{
        PC_curloc(24-row,78-strlen(str));
        PC_puts(str);
}

PC_ulput_text(row,str)
int row;
char str[];
{
        PC_curloc(row+1,2);
        PC_puts(str);
}

#ifdef CORONA
COR_init()
{
}

COR_graphics()
{
        graphics_on = TRUE;
        Vmode(3);
        grinit(screen);
        grandtx();
}

COR_text()
{
        if (graphics_on) {
                graphics_on = FALSE;
                while (!kbhit())
                        ;
        }
        grreset();
        txonly();
        Vmode(3);
}

COR_linetype(linetype)
{
        if (linetype > 2)
                linetype %= 3;
        mask = pattern[linetype+2];
}

COR_move(x,y)
{
        if (x < 0)
                startx = 0;
        else if (x > COR_XLAST)
                startx = COR_XLAST;
        else
                startx = x;

        if (y < 0)
                starty = 0;
        else if (y > COR_YLAST)
                starty = COR_YLAST;
        else
                starty = y;
}

COR_vector(x,y)
{
        if (x < 0)
                x = 0;
        else if (x > COR_XLAST)
                x = COR_XLAST;
        if (y < 0)
                y = 0;
        else if (y > COR_YLAST)
                y = COR_YLAST;

        Cor_line(startx,COR_YLAST-starty,x,COR_YLAST-y);
        startx = x;
        starty = y;
}

#define COR_lrput_text PC_lrput_text
#define COR_ulput_text PC_ulput_text

COR_reset()
{
}
#endif /* CORONA */


CGA_init()
{
        PC_color(1);            /* monochrome */
}

CGA_graphics()
{
        graphics_on = TRUE;
        Vmode(6);
}

CGA_text()
{
        if (graphics_on) {
                graphics_on = FALSE;
                while (!kbhit())
                        ;
                Vmode(3);
        }
}

CGA_linetype(linetype)
{
        if (linetype > 2)
                linetype %= 3;
        PC_mask(pattern[linetype+2]);
}

CGA_move(x,y)
{
        startx = x;
        starty = y;
}


CGA_vector(x,y)
{
        PC_line(startx,CGA_YLAST-starty,x,CGA_YLAST-y);
        startx = x;
        starty = y;
}

#define CGA_lrput_text PC_lrput_text
#define CGA_ulput_text PC_ulput_text


CGA_reset()
{
}


EGA_init()
{
        PC_mask(0xffff);
}

EGA_graphics()
{
        graphics_on = TRUE;
        Vmode(16);
}

EGA_text()
{
        PC_curloc(24,0);
        if (graphics_on) {
                graphics_on = FALSE;
                while (!kbhit())
                        ;
        }
}

EGA_linetype(linetype)
{
        static int c[] = {9, 8, 10, 11, 12, 13, 14, 15, 7, 5, 4, 3, 2, 6};
        PC_color(c[linetype+2]);
}

EGA_move(x,y)
{
        startx = x;
        starty = y;
}


EGA_vector(x,y)
{
        PC_line(startx,EGA_YLAST-starty,x,EGA_YLAST-y);
        startx = x;
        starty = y;
}

#define EGA_lrput_text PC_lrput_text
#define EGA_ulput_text PC_ulput_text


EGA_reset()
{
        Vmode(3);
}
#endif /* PC */


#ifdef AED
AED_init()
{
        fprintf(outfile,
        "\033SEN3DDDN.SEC.7.SCT.0.1.80.80.90.SBC.0.AAV2.MOV.0.9.CHR.0.FFD");
/*   2            3     4                5     7    6       1
        1. Clear Screen
        2. Set Encoding
        3. Set Default Color
        4. Set Backround Color Table Entry
        5. Set Backround Color
        6. Move to Bottom Lefthand Corner
        7. Anti-Alias Vectors
*/
}


AED_graphics()
{
        fprintf(outfile,"\033FFD\033");
}


AED_text()
{
        fprintf(outfile,"\033MOV.0.9.SEC.7.XXX");
}



AED_linetype(linetype)
int linetype;
{
static int color[9+2] = { 7, 1, 6, 2, 3, 5, 1, 6, 2, 3, 5 };
static int type[9+2] = { 85, 85, 255, 255, 255, 255, 255,
                                        85, 85, 85, 85 };

        fprintf(outfile,"\033SLS%d.255.",type[linetype+2]);
        fprintf(outfile,"\033SEC%d.",color[linetype+2]);

}



AED_move(x,y)
int x,y;
{
        fprintf(outfile,"\033MOV%d.%d.",x,y);
}


AED_vector(x,y)
int x,y;
{
        fprintf(outfile,"\033DVA%d.%d.",x,y);
}


AED_lrput_text(row,str) /* write text to screen while still in graphics mode */
int row;
char str[];
{
        AED_move(AED_XMAX-((strlen(str)+2)*AED_HCHAR),AED_VTIC+AED_VCHAR*(row+1));
        fprintf(outfile,"\033XXX%s\033",str);
}


AED_ulput_text(row,str) /* write text to screen while still in graphics mode */
int row;
char str[];
{
        AED_move(AED_HTIC*2,AED_YMAX-AED_VTIC-AED_VCHAR*(row+1));
        fprintf(outfile,"\033XXX%s\033",str);
}


#define hxt (AED_HTIC/2)
#define hyt (AED_VTIC/2)

AED_reset()
{
        fprintf(outfile,"\033SCT0.1.0.0.0.SBC.0.FFD");
}

#endif /* AED */




#ifdef HP75

HP75_init()
{
        fprintf(outfile,
        "\033.Y;IN;\033.P1:SC0,%d,0,%d;\nRO90;IP;CS20;SI0.2137,0.2812;\n",
                HP75_XMAX,HP75_YMAX);
/*       1      2  3       4             5    6  7
        1. turn on eavesdropping
        2. reset to power-up defaults
        3. enable XON/XOFF flow control
        4. set SCaling to 2000 x 2000
        5. rotate page 90 degrees
        6. ???
        7. set some character set stuff
*/
}


HP75_graphics()
{
        fputs("\033.Y",outfile);
/*         1
        1. enable eavesdropping
*/
}


HP75_text()
{
        fputs("NR;\033.Z",outfile);
/*         1  2
        1. go into 'view' mode
        2. disable plotter eavesdropping
*/
}


HP75_linetype(linetype)
int linetype;
{
        fprintf(outfile,"SP%d;\n",3+(linetype%8));
}


HP75_move(x,y)
int x,y;
{
        fprintf(outfile,"PU%d,%d;\n",x,y);
}


HP75_vector(x,y)
int x,y;
{
        fprintf(outfile,"PD%d,%d;\n",x,y);
}


HP75_lrput_text(row,str)
int row;
char str[];
{
        HP75_move(HP75_XMAX-HP75_HTIC*2,HP75_VTIC*2+HP75_VCHAR*row);
        fprintf(outfile,"LO17;LB%s\003\n",str);
}

HP75_ulput_text(row,str)
int row;
char str[];
{
        HP75_move(HP75_HTIC*2,HP75_YMAX-HP75_VTIC*2-HP75_VCHAR*row);
        fprintf(outfile,"LO13;LB%s\003\n",str);
}

HP75_reset()
{
}

#endif /* HP75 */



#ifdef REGIS

REGISinit()
{
        fprintf(outfile,"\033[r\033[24;1H");
/*                   1     2
        1. reset scrolling region
        2. locate cursor on bottom line
*/
}


REGISgraphics()
{
        fprintf(outfile,"\033[2J\033P1pS(C0)");
/*                   1      2      3
        1. clear screen
        2. enter ReGIS graphics
        3. turn off graphics diamond cursor
*/
}


REGIStext()
{
        fprintf(outfile,"\033[24;1H");
/*                       1
        1. locate cursor on last line of screen (and leave ReGIS)
*/
}


REGISlinetype(linetype)
int linetype;
{
        static int in_map[9+2] = {2,2,3,2,3,2,3,2,1,1,1};
        static int lt_map[9+2] = {1,4,1,1,4,4,6,6,1,4,6};
        fprintf(outfile,"W(I%d)",in_map[linetype+2]);
        fprintf(outfile,"W(P%d)",lt_map[linetype+2]);
}


REGISmove(x,y)
int x,y;
{
        fprintf(outfile,"P[%d,%d]v[]",x,REGISYLAST-y,x,REGISYLAST-y);
}


REGISvector(x,y)
int x,y;
{
        fprintf(outfile,"v[%d,%d]",x,REGISYLAST - y);
}


REGISlrput_text(row,str)
int row;
char *str;
{
        REGISmove(REGISXMAX-REGISHTIC-REGISHCHAR*(strlen(str)+3),
                REGISVTIC+REGISVCHAR*(row+1));
        (void) putc('T',outfile); (void) putc('\'',outfile);
        while (*str) {
                (void) putc(*str,outfile);
                if (*str == '\'')
                                (void) putc('\'',outfile);      /* send out another one */
                str++;
        }
        (void) putc('\'',outfile);
}


REGISulput_text(row,str)
int row;
char *str;
{
        REGISmove(REGISVTIC,REGISYMAX-REGISVTIC*2-REGISVCHAR*row);
        (void) putc('T',outfile); (void) putc('\'',outfile);
        while (*str) {
                (void) putc(*str,outfile);
                if (*str == '\'')
                                (void) putc('\'',outfile);      /* send out another one */
                str++;
        }
        (void) putc('\'',outfile);
}


REGISreset()
{
        fprintf(outfile,"\033[2J\033[24;1H");
}

#endif /* REGIS */




#ifdef QMS

QMS_init()
{
        fprintf(outfile,"^IOL\n");
}


QMS_graphics()
{
        fprintf(outfile,"^IGV\n");
}



QMS_text()
{
        fprintf(outfile,"^IGE\n^,");
}


QMS_linetype(linetype)
int linetype;
{
static int width[9+2] = {7, 3, 3, 3, 3, 5, 5, 5, 7, 7, 7};
static int type[9+2] =  {0, 0, 0, 2, 5, 0, 2, 5, 0, 2, 5};
        fprintf(outfile,"^PW%02d\n^V%x\n",width[linetype+2], type[linetype+2]);
}


QMS_move(x,y)
int x,y;
{
        fprintf(outfile,"^U%05d:%05d\n", 1000 + x, QMS_YLAST + 1000 - y);
}


QMS_vector(x2,y2)
int x2,y2;
{
        fprintf(outfile,"^D%05d:%05d\n", 1000 + x2, QMS_YLAST + 1000 - y2);
}


QMS_lrput_text(row,str)
int row;
char str[];
{
        QMS_move(QMS_XMAX-QMS_HTIC-QMS_HCHAR*(strlen(str)+1),
                QMS_VTIC+QMS_VCHAR*(row+1));
        fprintf(outfile,"^IGE\n%s\n^IGV\n",str);
}

QMS_ulput_text(row,str)
int row;
char str[];
{
        QMS_move(QMS_HTIC*2,QMS_YMAX-QMS_VTIC-QMS_VCHAR*(row+1));
        fprintf(outfile,"^IGE\n%s\n^IGV\n",str);
}


QMS_reset()
{
        fprintf(outfile,"^,\n");
}

#endif /* QMS */



#ifdef TEK

#define HX 0x20         /* bit pattern to OR over 5-bit data */
#define HY 0x20
#define LX 0x40
#define LY 0x60

#define LOWER5 31
#define UPPER5 (31<<5)


TEK40init()
{
}


TEK40graphics()
{
        fprintf(outfile,"\033\014");
/*                   1
        1. clear screen
*/
}


TEK40text()
{
        TEK40move(0,12);
        fprintf(outfile,"\037");
/*                   1
        1. into alphanumerics
*/
}


TEK40linetype(linetype)
int linetype;
{
}



TEK40move(x,y)
unsigned int x,y;
{
        (void) putc('\035', outfile);   /* into graphics */
        TEK40vector(x,y);
}


TEK40vector(x,y)
unsigned int x,y;
{
        (void) putc((HY | (y & UPPER5)>>5), outfile);
        (void) putc((LY | (y & LOWER5)), outfile);
        (void) putc((HX | (x & UPPER5)>>5), outfile);
        (void) putc((LX | (x & LOWER5)), outfile);
}


TEK40lrput_text(row,str)
unsigned int row;
char str[];
{
        TEK40move(TEK40XMAX - TEK40HTIC - TEK40HCHAR*(strlen(str)+1),
                TEK40VTIC + TEK40VCHAR*(row+1));
        fprintf(outfile,"\037%s\n",str);
}


TEK40ulput_text(row,str)
unsigned int row;
char str[];
{
        TEK40move(TEK40HTIC, TEK40YMAX - TEK40VTIC - TEK40VCHAR*(row+1));
        fprintf(outfile,"\037%s\n",str);
}


TEK40reset()
{
}

#endif /* TEK */


#ifdef UNIXPLOT
UP_init()
{
        openpl();
        space(0, 0, UP_XMAX, UP_YMAX);
}


UP_graphics()
{
        erase();
}


UP_text()
{
}


UP_linetype(linetype)
int linetype;
{
static char *lt[] = {"solid", "longdashed", "solid", "dotted", "shortdashed",
        "dotdashed", "longdashed"};

        if (linetype >= 5)
                linetype %= 5;
        linemod(lt[linetype+2]);
}


UP_move(x,y)
unsigned int x,y;
{
        move(x,y);
}


UP_vector(x,y)
unsigned int x,y;
{
        cont(x,y);
}


UP_lrput_text(row,str)
unsigned int row;
char str[];
{
        move(UP_XMAX - UP_HTIC - UP_HCHAR*(strlen(str)+1),
                UP_VTIC + UP_VCHAR*(row+1));
        label(str);
}


UP_ulput_text(row,str)
unsigned int row;
char str[];
{
        UP_move(UP_HTIC, UP_YMAX - UP_VTIC - UP_VCHAR*(row+1));
        label(str);
}

UP_reset()
{
        closepl();
}

#endif /* UNIXPLOT */



UNKNOWN_null()
{
        int_error("you must set your terminal type before plotting!",NO_CARET);
}


/*
 * term_tbl[] contains an entry for each terminal.  "unknown" must be the
 *   first, since term is initialized to 0.
 */
struct termentry term_tbl[] = {
        {"unknown", 100, 100, 1, 1, 1, 1, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null,
        UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null,
        UNKNOWN_null, UNKNOWN_null}
#ifdef PC
        ,{"cga", CGA_XMAX, CGA_YMAX, CGA_VCHAR, CGA_HCHAR,
                CGA_VTIC, CGA_HTIC, CGA_init, CGA_reset,
                CGA_text, CGA_graphics, CGA_move, CGA_vector,
                CGA_linetype, CGA_lrput_text, CGA_ulput_text, line_and_point}
        ,{"ega", EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
                EGA_VTIC, EGA_HTIC, EGA_init, EGA_reset,
                EGA_text, EGA_graphics, EGA_move, EGA_vector,
                EGA_linetype, EGA_lrput_text, EGA_ulput_text, do_point}

#ifdef CORONA
        ,{"corona", COR_XMAX, COR_YMAX, COR_VCHAR, COR_HCHAR,
                COR_VTIC, COR_HTIC, COR_init, COR_reset,
                COR_text, COR_graphics, COR_move, COR_vector,
                COR_linetype, COR_lrput_text, COR_ulput_text, line_and_point}
#endif /* CORONA */
#endif /* PC */

#ifdef AED
        ,{"aed767", AED_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
                AED_VTIC, AED_HTIC, AED_init, AED_reset,
                AED_text, AED_graphics, AED_move, AED_vector,
                AED_linetype, AED_lrput_text, AED_ulput_text, do_point}
#endif

#ifdef HP75
        ,{"hp75xx",HP75_XMAX,HP75_YMAX, HP75_VCHAR, HP75_HCHAR,HP75_VTIC,HP75_HTIC,
                HP75_init,HP75_reset,HP75_text, HP75_graphics, HP75_move, HP75_vector,
                HP75_linetype, HP75_lrput_text, HP75_ulput_text, do_point}
#endif

#ifdef QMS
        ,{"qms",QMS_XMAX,QMS_YMAX, QMS_VCHAR, QMS_HCHAR, QMS_VTIC, QMS_HTIC,
                QMS_init,QMS_reset, QMS_text, QMS_graphics, QMS_move, QMS_vector,
                QMS_linetype,QMS_lrput_text,QMS_ulput_text,line_and_point}
#endif

#ifdef REGIS
        ,{"regis", REGISXMAX, REGISYMAX, REGISVCHAR, REGISHCHAR, REGISVTIC,
                REGISHTIC, REGISinit, REGISreset, REGIStext, REGISgraphics,
                REGISmove,REGISvector,REGISlinetype, REGISlrput_text, REGISulput_text,
                line_and_point}
#endif

#ifdef TEK
        ,{"tek40xx",TEK40XMAX,TEK40YMAX,TEK40VCHAR, TEK40HCHAR, TEK40VTIC,
                TEK40HTIC, TEK40init,TEK40reset, TEK40text, TEK40graphics,
                TEK40move, TEK40vector,TEK40linetype,TEK40lrput_text,
                TEK40ulput_text, line_and_point}
#endif

#ifdef UNIXPLOT
        ,{"unixplot", UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR, UP_VTIC, UP_HTIC,
                UP_init, UP_reset, UP_text, UP_graphics, UP_move, UP_vector,
                UP_linetype, UP_lrput_text, UP_ulput_text, line_and_point}
#endif
        };


list_terms()
{
register int i;

        (void) putc('\n',stderr);
        fprintf(stderr,"available terminals types: \n");
        for (i = 0; i < TERMCOUNT; i++)
                fprintf(stderr,"\t%s\n",term_tbl[i].name);
        (void) putc('\n',stderr);
}


set_term(c_token)
int c_token;
{
register int i,t;

        if (!token[c_token].is_token)
                int_error("terminal name expected",c_token);
        t = -1;
        for (i = 0; i < TERMCOUNT; i++) {
                if (!strncmp(input_line + token[c_token].start_index,term_tbl[i].name,
                        token[c_token].length)) {
                        if (t != -1)
                                int_error("ambiguous terminal name",c_token);
                        t = i;
                }
        }
        if (t == -1)
                int_error("unknown terminal type; type just 'set terminal' for a list",
                        c_token);
        term_init = FALSE;
        return(t);
}
SHAR_EOF
if test 17424 -ne "`wc -c < 'term.c'`"
then
        echo shar: error transmitting "'term.c'" '(should have been 17424 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'util.c'" '(7934 characters)'
if test -f 'util.c'
then
        echo shar: will not over-write existing file "'util.c'"
else
cat << \SHAR_EOF > 'util.c'
/*
 *
 *    G N U P L O T  --  util.c
 *
 *  Copyright (C) 1986 Thomas Williams, Colin Kelley
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#include <ctype.h>
#include <setjmp.h>
#include <stdio.h>
#include <errno.h>
#include "plot.h"

extern BOOLEAN screen_ok;
        /* TRUE if command just typed; becomes FALSE whenever we
                send some other output to screen.  If FALSE, the command line
                will be echoed to the screen before the ^ error message. */

#ifndef vms
extern int errno, sys_nerr;
extern char *sys_errlist[];
#endif /* vms */

extern char input_line[MAX_LINE_LEN];
extern struct lexical_unit token[MAX_TOKENS];
extern jmp_buf env;     /* from plot.c */


/*
 * equals() compares string value of token number t_num with str[], and
 *   returns TRUE if they are identical.
 */
equals(t_num, str)
int t_num;
char *str;
{
register int i;

        if (!token[t_num].is_token)
                return(FALSE);                          /* must be a value--can't be equal */
        for (i = 0; i < token[t_num].length; i++) {
                if (input_line[token[t_num].start_index+i] != str[i])
                        return(FALSE);
                }
        /* now return TRUE if at end of str[], FALSE if not */
        return(str[i] == '\0');
}



/*
 * almost_equals() compares string value of token number t_num with str[], and
 *   returns TRUE if they are identical up to the first $ in str[].
 */
almost_equals(t_num, str)
int t_num;
char *str;
{
register int i;
register int after = 0;
register start = token[t_num].start_index;
register length = token[t_num].length;

        if (!token[t_num].is_token)
                return(FALSE);                          /* must be a value--can't be equal */
        for (i = 0; i < length + after; i++) {
                if (str[i] != input_line[start + i]) {
                        if (str[i] != '$')
                                return(FALSE);
                        else {
                                after = 1;
                                start--;        /* back up token ptr */
                                }
                        }
                }

        /* i now beyond end of token string */

        return(after || str[i] == '$' || str[i] == '\0');
}



isstring(t_num)
int t_num;
{

        return(token[t_num].is_token &&
                   (input_line[token[t_num].start_index] == '\'' ||
                   input_line[token[t_num].start_index] == '\"'));
}


isnumber(t_num)
int t_num;
{
        return(!token[t_num].is_token);
}


isletter(t_num)
int t_num;
{
        return(token[t_num].is_token &&
                        (isalpha(input_line[token[t_num].start_index])));
}


/*
 * is_definition() returns TRUE if the next tokens are of the form
 *   identifier =
 *              -or-
 *   identifier ( identifer ) =
 */
is_definition(t_num)
int t_num;
{
        return (isletter(t_num) &&
                        (equals(t_num+1,"=") ||                 /* variable */
                        (equals(t_num+1,"(") &&         /* function */
                         isletter(t_num+2)   &&
                         equals(t_num+3,")") &&
                         equals(t_num+4,"=") )
                ));
}



/*
 * copy_str() copies the string in token number t_num into str, appending
 *   a null.  No more than MAX_ID_LEN chars are copied.
 */
copy_str(str, t_num)
char str[];
int t_num;
{
register int i = 0;
register int start = token[t_num].start_index;
register int count;

        if ((count = token[t_num].length) > MAX_ID_LEN)
                count = MAX_ID_LEN;
        do {
                str[i++] = input_line[start++];
                } while (i != count);
        str[i] = '\0';
}


/*
 * quote_str() does the same thing as copy_str, except it ignores the
 *   quotes at both ends.  This seems redundant, but is done for
 *   efficency.
 */
quote_str(str, t_num)
char str[];
int t_num;
{
register int i = 0;
register int start = token[t_num].start_index + 1;
register int count;

        if ((count = token[t_num].length - 2) > MAX_ID_LEN)
                count = MAX_ID_LEN;
        do {
                str[i++] = input_line[start++];
                } while (i != count);
        str[i] = '\0';
}

/*
 *      capture() returns in str[] the the part of input_line[] which lies
 *      between the begining of token[start] and end of token[end]
 */
capture(str,start,end)
char str[];
int start,end;
{
register int i,j;
char *s = str;

        j = token[end].start_index + token[end].length;
        for (i = token[start].start_index; i < j && input_line[i] != '\0'; i++)
                *s++ = input_line[i];
        *s = '\0';
}


convert(val_ptr, t_num)
struct value *val_ptr;
int t_num;
{
        *val_ptr = token[t_num].l_val;
}



show_value(fp,val)
FILE *fp;
struct value *val;
{
                switch(val->type) {
                        case INT:
                                fprintf(fp,"%d",val->v.int_val);
                                break;
                        case CMPLX:
                                if (val->v.cmplx_val.imag != 0.0 )
                                        fprintf(fp,"{%g, %g}",
                                                val->v.cmplx_val.real,val->v.cmplx_val.imag);
                                else
                                        fprintf(fp,"%g", val->v.cmplx_val.real);
                                break;
                        default:
                                int_error("unknown type in show_value()",NO_CARET);
                }
}


double
real(val)               /* returns the real part of val */
struct value *val;
{
        switch(val->type) {
                case INT:
                        return((double) val->v.int_val);
                        break;
                case CMPLX:
                        return(val->v.cmplx_val.real);
        }
        int_error("unknown type in real()",NO_CARET);
        /* NOTREACHED */
}


double
imag(val)               /* returns the imag part of val */
struct value *val;
{
        switch(val->type) {
                case INT:
                        return(0.0);
                        break;
                case CMPLX:
                        return(val->v.cmplx_val.imag);
        }
        int_error("unknown type in real()",NO_CARET);
        /* NOTREACHED */
}



double
magnitude(val)          /* returns the magnitude of val */
struct value *val;
{
        double sqrt();

        switch(val->type) {
                case INT:
                        return((double) abs(val->v.int_val));
                        break;
                case CMPLX:
                        return(sqrt(val->v.cmplx_val.real*
                                    val->v.cmplx_val.real +
                                    val->v.cmplx_val.imag*
                                    val->v.cmplx_val.imag));
        }
        int_error("unknown type in magnitude()",NO_CARET);
        /* NOTREACHED */
}



double
angle(val)              /* returns the angle of val */
struct value *val;
{
        double atan2();

        switch(val->type) {
                case INT:
                        return((val->v.int_val > 0) ? 0.0 : Pi);
                        break;
                case CMPLX:
                        if (val->v.cmplx_val.imag == 0.0) {
                                if (val->v.cmplx_val.real >= 0.0)
                                        return(0.0);
                                else
                                        return(Pi);
                        }
                        return(atan2(val->v.cmplx_val.imag,
                                     val->v.cmplx_val.real));
        }
        int_error("unknown type in angle()",NO_CARET);
        /* NOTREACHED */
}


struct value *
complex(a,realpart,imagpart)
struct value *a;
double realpart, imagpart;
{
        a->type = CMPLX;
        a->v.cmplx_val.real = realpart;
        a->v.cmplx_val.imag = imagpart;
        return(a);
}


struct value *
integer(a,i)
struct value *a;
int i;
{
        a->type = INT;
        a->v.int_val = i;
        return(a);
}



os_error(str,t_num)
char str[];
int t_num;
{
#ifdef vms
static status[2] = {1, 0};              /* 1 is count of error msgs */
#endif

register int i;

        /* reprint line if screen has been written to */

        if (t_num != NO_CARET) {                /* put caret under error */
                if (!screen_ok)
                        fprintf(stderr,"\n%s%s\n", PROMPT, input_line);

                for (i = 0; i < sizeof(PROMPT) - 1; i++)
                        (void) putc(' ',stderr);
                for (i = 0; i < token[t_num].start_index; i++) {
                        (void) putc((input_line[i] == '\t') ? '\t' : ' ',stderr);
                        }
                (void) putc('^',stderr);
                (void) putc('\n',stderr);
        }

        for (i = 0; i < sizeof(PROMPT) - 1; i++)
                (void) putc(' ',stderr);
        fprintf(stderr,"%s\n",str);

        for (i = 0; i < sizeof(PROMPT) - 1; i++)
                (void) putc(' ',stderr);
#ifdef vms
        status[1] = vaxc$errno;
        sys$putmsg(status);
        (void) putc('\n',stderr);
#else
        if (errno >= sys_nerr)
                fprintf(stderr, "unknown errno %d\n\n", errno);
        else
                fprintf(stderr,"(%s)\n\n",sys_errlist[errno]);
#endif

        longjmp(env, TRUE);     /* bail out to command line */
}


int_error(str,t_num)
char str[];
int t_num;
{
register int i;

        /* reprint line if screen has been written to */

        if (t_num != NO_CARET) {                /* put caret under error */
                if (!screen_ok)
                        fprintf(stderr,"\n%s%s\n", PROMPT, input_line);

                for (i = 0; i < sizeof(PROMPT) - 1; i++)
                        (void) putc(' ',stderr);
                for (i = 0; i < token[t_num].start_index; i++) {
                        (void) putc((input_line[i] == '\t') ? '\t' : ' ',stderr);
                        }
                (void) putc('^',stderr);
                (void) putc('\n',stderr);
        }

        for (i = 0; i < sizeof(PROMPT) - 1; i++)
                (void) putc(' ',stderr);
        fprintf(stderr,"%s\n\n",str);

        longjmp(env, TRUE);     /* bail out to command line */
}
SHAR_EOF
if test 7934 -ne "`wc -c < 'util.c'`"
then
        echo shar: error transmitting "'util.c'" '(should have been 7934 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'version.c'" '(72 characters)'
if test -f 'version.c'
then
        echo shar: will not over-write existing file "'version.c'"
else
cat << \SHAR_EOF > 'version.c'
char version[] = "1.0.3";
char date[] = "Sun Nov 16 20:31:40 EST 1986";
SHAR_EOF
if test 72 -ne "`wc -c < 'version.c'`"
then
        echo shar: error transmitting "'version.c'" '(should have been 72 characters)'
fi
fi # end of overwriting check
#       End of shell archive
exit 0
