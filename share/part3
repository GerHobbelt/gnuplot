#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#       README
#       gnuplot.1
#       Makefile
#       make.msc
#       corgraph.asm
#       pcgraph.asm
#       plot.h
#       vmshelp.csh
#       simple.demo
#       1.dat
#       2.dat
#       3.dat
# This archive created: Mon Nov 17 19:08:27 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'README'" '(1701 characters)'
if test -f 'README'
then
        echo shar: will not over-write existing file "'README'"
else
cat << \SHAR_EOF > 'README'
GNUPLOT has been tested on a Pyramid 90x (ucb 4.2 and att V),
a VAX 8200 (VMS 4.3), IBM PC's and AT's (MS-DOS 3.1, Microsoft C 4.0).
The code is written with portability in mind, and it passes lint!
If you have problems, send mail to vu-vlsi!plot.  And please send
any modifications you make so they can be #ifdef'd into later releases.

These #defines should be checked before compilation:

VFORK       Makefile        define if you've got vfork() system call
vms         Makefile        define if compiling under VMS;
                              automatically defined by DEC C
PC          Makefile        define if compiling on a PClone
MSDOS       Makefile        define if compiling under MSDOS;
                              automatically defined by Microsoft C 4.0
AED         Makefile        define these if you want this terminal driver
HP75           .              included
QMS            .
REGIS          .
TEK            .
UNIXPLOT       .

CGA            .            same, but only if PC is defined
CORONA         .
EGA            .

HUGE        plot.h          define to be largest double if not defined
                              in <math.h>
HELP        plot.h          program run by 'help' command
SHELL       plot.h          default shell to spawn if SHELL environment
                              variable not found at run-time

To compile:

under UNIX:  type 'make'

under VMS:  type '@compile', then '@link'.  Use the 'vmshelp.csh' script
to convert the help files.  If you don't have access to a Unix machine,
send us mail and we'll send you the VMS GNUPLOT.HLB.

under MSDOS:  use 'make make.msc' for Microsoft C 4.0.  If you've got
another compiler, you're on your own!
SHAR_EOF
if test 1701 -ne "`wc -c < 'README'`"
then
        echo shar: error transmitting "'README'" '(should have been 1701 characters)'
fi
chmod +x 'README'
fi # end of overwriting check
echo shar: extracting "'gnuplot.1'" '(1364 characters)'
if test -f 'gnuplot.1'
then
        echo shar: will not over-write existing file "'gnuplot.1'"
else
cat << \SHAR_EOF > 'gnuplot.1'
.\" dummy line
.TH GNUPLOT 1 "17 November 1986"
.UC 4
.SH NAME
gnuplot \- an interactive plotting program
.SH SYNOPSIS
.B gnuplot
.br
.SH DESCRIPTION
.I   GNUPLOT
is a command-driven interactive function plotting program.
Here are some of its features:
.PP
  Plots any number of functions, built up of C operators, C library
functions, and some things C doesn't have like **, sgn(), etc.  Also
support for plotting scatter-plots of data files for comparing actual
data to theoretical curves.
.PP
  User-defined X and Y ranges (optional Y auto-ranging), smart Y scaling,
smart tic marks.
.PP
  User-defined constants and functions.
.PP
  Support through a generalized graphics driver for ReGis (VT125 and VT2xx),
Tek 401x, AED 767, HP plotters, and QMS laser printers.  The PC version
supports IBM CGA & EGA and Corona 325 graphics.  Other devices can be added
simply, but will require recompiling.
.PP
  Shell escapes and command line substitution.
.PP
  Load and save capability.
.PP
  Output redirection.
.PP
  All computations performed in the complex domain.  Just the real part is
plotted by default, but functions like imag() and abs() and arg() are
available to override this.
.SH AUTHORS
Colin Kelley and Tom Williams (vu-vlsi!plot)
.SH BUGS
The unixplot driver automatically writes to stdout, so you have to
redirect the gnuplot's output from the shell.
SHAR_EOF
if test 1364 -ne "`wc -c < 'gnuplot.1'`"
then
        echo shar: error transmitting "'gnuplot.1'" '(should have been 1364 characters)'
fi
chmod +x 'gnuplot.1'
fi # end of overwriting check
echo shar: extracting "'Makefile'" '(1512 characters)'
if test -f 'Makefile'
then
        echo shar: will not over-write existing file "'Makefile'"
else
cat << \SHAR_EOF > 'Makefile'
# where to install on 'make install'
DEST=/usr/local/bin/gnuplot

OBJS =  plot.o scanner.o parse.o command.o eval.o standard.o internal.o util.o\
        graphics.o term.o misc.o version.o

CSOURCE1 = command.c eval.c graphics.c internal.c misc.c
CSOURCE2 = parse.c plot.c scanner.c standard.c term.c util.c version.c
# not C code, but still needed
ETC = README gnuplot.1 Makefile make.msc corgraph.asm pcgraph.asm plot.h\
    vmshelp.csh simple.demo 1.dat 2.dat 3.dat

# -lplot iff UNIXPLOT you have -DUNIXPLOT
LIBS = -lm -lplot

# -DFORK iff vfork() supported
CFLAGS = -O -DVFORK

# -D<terminal> only if you wish to support <terminal>
# -DAED        Aed767
# -HP75        HP7580, and probably other HPs
# -DQMS        QMS/QUIC laserprinter (Talaris 1200 and others)
# -DREGIS      ReGis graphics (vt220, vt240, Gigis...)
# -DTEK        Tektronix 4010, and probably others
# -DUNIXPLOT   unixplot

TERMFLAGS = -DAED -DHP75 -DQMS -DREGIS -DTEK -DUNIXPLOT

gnuplot: $(OBJS)
        cc $(CFLAGS) $(OBJS) version.o $(LIBS) -o gnuplot

install: gnuplot
        cp gnuplot $(DEST)
        strip $(DEST)

term.o: term.c
        cc $(CFLAGS) $(TERMFLAGS) -c term.c

$(OBJS): plot.h

lint:
        lint -hx $(CSOURCE1) $(CSOURCE2)

shar: gnuplot.shar.1 gnuplot.shar.2 gnuplot.shar.3 gnuplot.shar.4

gnuplot.shar.1: $(CSOURCE1)
        shar -vc $(CSOURCE1) > gnuplot.shar.1

gnuplot.shar.2: $(CSOURCE2)
        shar -vc $(CSOURCE2) > gnuplot.shar.2

gnuplot.shar.3: $(ETC)
        shar -vc $(ETC) > gnuplot.shar.3

gnuplot.shar.4:
        cd /usr/help; shar -vc gnuplot > gnuplot.shar.4
SHAR_EOF
if test 1512 -ne "`wc -c < 'Makefile'`"
then
        echo shar: error transmitting "'Makefile'" '(should have been 1512 characters)'
fi
chmod +x 'Makefile'
fi # end of overwriting check
echo shar: extracting "'make.msc'" '(1097 characters)'
if test -f 'make.msc'
then
        echo shar: will not over-write existing file "'make.msc'"
else
cat << \SHAR_EOF > 'make.msc'
OBJS =  command.obj eval.obj graphics.obj internal.obj misc.obj parse.obj plot.obj scanner.obj standard.obj term.obj util.obj version.obj pcgraph.obj corgraph.obj

LIBFLAGS =

# corgraph will include code for Corona 325 graphics
# if omitted, be sure to delete corgraph elsewhere, and get rid of
#   /DCORONA in CFLAGS
GRAPHICS = pcgraph+corgraph

# /AL means use large model (necessary!)
CFLAGS = /AL /DPC /DCORONA

# default rules
.c.obj:
        msc $(CFLAGS) $*;

.asm.obj:
        masm $*;


pcgraph.obj: pcgraph.asm

corgraph.obj: corgraph.asm

command.obj: command.c plot.h

eval.obj: eval.c plot.h

graphics.obj: graphics.c plot.h

internal.obj: internal.c plot.h

misc.obj: misc.c plot.h

parse.obj: parse.c plot.h

plot.obj: plot.c plot.h

scanner.obj: scanner.c plot.h

standard.obj: standard.c plot.h

term.obj: term.c plot.h

util.obj: util.c plot.h

version.obj: version.c

gnuplot.exe: $(OBJS)
        link$(LIBFLAGS) command+eval+graphics+internal+misc+parse+plot+scanner+standard+term+util+version+$(GRAPHICS),gnuplot,nul,;
x               ; sum,dx
        add bx,si               ; y1,y2
i27:
        inc ax                  ; x1
        cmp ax,cx               ; x1,x2
        jbe
SHAR_EOF
echo shar: a missing newline was added to "'make.msc'"
if test 1097 -ne "`wc -c < 'make.msc'`"
then
        echo shar: error transmitting "'make.msc'" '(should have been 1097 characters)'
fi
chmod +x 'make.msc'
fi # end of overwriting check
echo shar: extracting "'corgraph.asm'" '(3592 characters)'
if test -f 'corgraph.asm'
then
        echo shar: will not over-write existing file "'corgraph.asm'"
else
cat << \SHAR_EOF > 'corgraph.asm'
TITLE   Corona graphics module
;       Colin Kelley
;       November 9, 1986

xmax    equ 640                 ; Corona Screen
ymax    equ 325                 ;


X       equ 6


public  _GrInit,_GrReset,_GrAddr,_GrOnly,_TxOnly,_GrandTx,_Cor_line

_prog   segment para 'code'
        assume cs:_prog
X       equ 6

_Cor_line proc far
        push bp
        mov bp,sp
        push si
        push di
        mov ax,[bp+X]           ; x1
        mov bx,[bp+X+2]         ; y1
        mov cx,[bp+X+4]         ; x2
        mov si,[bp+X+6]         ; y2

        cmp ax,cx               ; x1,x2
        jne i19
        cmp bx,si               ; y1,y2
        jne i19

        call near ptr corpixel

        jmp short i28
i19:
        mov dx,ax               ; dx,x1
        sub dx,cx               ; x2
        jnc noabsx
        neg dx
noabsx:
        mov di,bx               ; dy,y1
        sub di,si               ; y2
        jnc noabsy
        neg di                  ; dy
noabsy:
        cmp dx,di               ; dx,dy
        ja jcc91
        jmp short i21
jcc91:
        cmp ax,cx               ; x1,x2
        jbe i22
        xchg ax,cx              ; x1,x2
        xchg bx,si              ; y1,y2
i22:
        cmp bx,si               ; y1,y2
        jae l20004
        mov si,1                ; y2,1
        jmp short l20005
l20004:
        mov si,-1               ; y2,-1
l20005:
        mov bp,dx               ; sum,dx
        shr bp,1                ; sum,1
d23:
        ;check out mask
        call near ptr corpixel
        add bp,di               ; sum,dy
        cmp bp,dx
        jb i27
        sub bp,dx               ; sum,dx
        add bx,si               ; y1,y2
i27:
        inc ax                  ; x1
        cmp ax,cx               ; x1,x2
        jbe d23
        jmp short i28

; else iterate y's
i21:
        cmp bx,si               ; y1,y2
        jbe i29
        xchg ax,cx              ; x1,x2
        xchg bx,si              ; y1,y2
i29:
        cmp ax,cx               ; x1,x2
        jae l20006
        mov cx,1                ; x2,1
        jmp short l20007
l20006:
        mov cx,-1               ; x2,-1
l20007:
        mov bp,di               ; sum,dy
        shr bp,1                ; sum,1
d30:
        ; check out mask
        call near ptr corpixel
        add bp,dx               ; sum,dx
        cmp bp,di               ; sum,dy
        jb i34
        sub bp,di               ; sum,dy
        add ax,cx               ; x1,x2
i34:
        inc bx                  ; y1
        cmp bx,si               ; y2
        jbe d30
i28:
        pop di
        pop si
        pop bp
        ret
_Cor_line endp


_GrInit proc far
        push bp
        mov bp,sp
        push di
        mov ax, [bp+X]          ; offset of screen
        add ax,15
        mov cl,4
        shr ax,cl
        add ax, [bp+X+2]        ; add segment
        add ax, (32768/16)-1
        and ax, 65535-((32768/16)-1)    ; round up to 32K boundary
        mov cs:ScSeg,ax         ; save segment for later
        push ax
        mov es, ax
        xor ax,ax
        mov di,ax
        mov cx, 4000h
        cld
        rep stosw
        pop cx
        call far ptr _GrAddr
        mov ax,es
        pop di
        pop bp
        ret
_GrInit endp

_GrReset proc far
        mov cx, 0
        call far ptr _GrAddr
        ret
_GrReset endp

_GrAddr proc far
        mov dx,3b4h                     ; address of 6845
        mov al,0ch                      ; register 12
        out dx,al
        inc dx
        mov al,ch                       ; Graphics Segment High
        out dx,al
        dec dx
        mov al,0dh                      ; register 13
        out dx,al
        mov al,cl                       ; Graphics Segment Low
        inc dx
        out dx,al
        ret
_GrAddr endp

_GrOnly proc far
        mov dx,3b8h
        mov al,0a0h
        out dx,al
        ret
_GrOnly endp

_TxOnly proc far
        mov dx,3b8h
        mov al,28h
        out dx,al
        ret
_TxOnly endp

_GrandTx proc far
        mov dx,3b8h
        mov al,0a8h
        out dx,al
        ret
_GrandTx endp

corpixel proc near
        push bp
        mov bp,sp
        push ax
        push bx
        push cx
        mov es,cs:ScSeg
        shl bx,1                        ; y
        mov bx,word ptr cs:LookUp[bx] ; bx has y mem address
        mov cl,al                       ; x
        and cl,7
        shr ax,1
        shr ax,1
        shr ax,1                        ; ax /= 8
        add bx,ax
        mov al,1
        shl al,cl                       ; al contains bit mask
        or byte ptr es:[bx],al
        pop cx
        pop bx
        pop ax
        pop bp
        ret

K       equ 1024

mem_mac MACRO x
        dw x,2*K+x,4*K+x,6*K+x,8*K+x,10*K+x,12*K+x,14*K+x,16*K+x
        dw 18*K+x,20*K+x,22*K+x,24*K+x
        ENDM

ScSeg   dw 0

LookUp  equ $
        mem_mac 0
        mem_mac 80
        mem_mac (80*2)
        mem_mac (80*3)
        mem_mac (80*4)
        mem_mac (80*5)
        mem_mac (80*6)
        mem_mac (80*7)
        mem_mac (80*8)
        mem_mac (80*9)
        mem_mac (80*10)
        mem_mac (80*11)
        mem_mac (80*12)
        mem_mac (80*13)
        mem_mac (80*14)
        mem_mac (80*15)
        mem_mac (80*16)
        mem_mac (80*17)
        mem_mac (80*18)
        mem_mac (80*19)
        mem_mac (80*20)
        mem_mac (80*21)
        mem_mac (80*22)
        mem_mac (80*23)
        mem_mac (80*24)
corpixel endp

_prog   ends

        end
................ ... ...-....1200 N81N         ......................... ... ...-....1200 N81N
SHAR_EOF
echo shar: a missing newline was added to "'corgraph.asm'"
echo shar: 8 control characters may be missing from "'corgraph.asm'"
if test 3592 -ne "`wc -c < 'corgraph.asm'`"
then
        echo shar: error transmitting "'corgraph.asm'" '(should have been 3592 characters)'
fi
chmod +x 'corgraph.asm'
fi # end of overwriting check
echo shar: extracting "'pcgraph.asm'" '(2618 characters)'
if test -f 'pcgraph.asm'
then
        echo shar: will not over-write existing file "'pcgraph.asm'"
else
cat << \SHAR_EOF > 'pcgraph.asm'
TITLE   PC graphics module

;       Colin Kelley
;       November 9, 1986

        public _PC_line, _PC_color, _PC_mask, _PC_curloc, _PC_puts, _Vmode

_prog   segment para 'code'
        assume cs:_prog

X       equ 6

_PC_line proc far
        push bp
        mov bp,sp
        push si
        push di
        mov ax,[bp+X]           ; x1
        mov bx,[bp+X+2]         ; y1
        mov cx,[bp+X+4]         ; x2
        mov si,[bp+X+6]         ; y2

        cmp ax,cx               ; x1,x2
        jne i19
        cmp bx,si               ; y1,y2
        jne i19

        call near ptr pcpixel

        jmp short i28
i19:
        mov dx,ax               ; dx,x1
        sub dx,cx               ; x2
        jnc noabsx
        neg dx
noabsx:
        mov di,bx               ; dy,y1
        sub di,si               ; y2
        jnc noabsy
        neg di                  ; dy
noabsy:
        cmp dx,di               ; dx,dy
        ja jcc91
        jmp short i21
jcc91:
        cmp ax,cx               ; x1,x2
        jbe i22
        xchg ax,cx              ; x1,x2
        xchg bx,si              ; y1,y2
i22:
        cmp bx,si               ; y1,y2
        jae l20004
        mov si,1                ; y2,1
        jmp short l20005
l20004:
        mov si,-1               ; y2,-1
l20005:
        mov bp,dx               ; sum,dx
        shr bp,1                ; sum,1
d23:
        call near ptr pcpixel
        add bp,di               ; sum,dy
        cmp bp,dx
        jb i27
        sub bp,dx               ; sum,dx
        add bx,si               ; y1,y2
i27:
        inc ax                  ; x1
        cmp ax,cx               ; x1,x2
        jbe d23
        jmp short i28

; else iterate y's
i21:
        cmp bx,si               ; y1,y2
        jbe i29
        xchg ax,cx              ; x1,x2
        xchg bx,si              ; y1,y2
i29:
        cmp ax,cx               ; x1,x2
        jae l20006
        mov cx,1                ; x2,1
        jmp short l20007
l20006:
        mov cx,-1               ; x2,-1
l20007:
        mov bp,di               ; sum,dy
        shr bp,1                ; sum,1
d30:
        call near ptr pcpixel
        add bp,dx               ; sum,dx
        cmp bp,di               ; sum,dy
        jb i34
        sub bp,di               ; sum,dy
        add ax,cx               ; x1,x2
i34:
        inc bx                  ; y1
        cmp bx,si               ; y2
        jbe d30
i28:
        pop di
        pop si
        pop bp
        ret
_PC_line endp

_PC_color proc far
        push bp
        mov bp,sp
        mov al,[bp+X]                   ; color
        mov byte ptr cs:color,al
        pop bp
        ret
_PC_color endp

_PC_mask proc far
        push bp
        mov bp,sp
        mov ax,[bp+X]                   ; mask
        mov word ptr cs:mask,ax
        pop bp
        ret
_PC_mask endp

mask    dw -1
color   db 1

_Vmode  proc far
        push bp
        mov bp,sp
        push si
        push di
        mov ax,[bp+X]
        int 10h
        pop di
        pop si
        pop bp
        ret
_Vmode  endp

pcpixel proc near
        ror word ptr cs:mask,1
        jc cont
        ret
cont:
        push ax
        push bx
        push cx
        push dx
        mov cx,ax               ; x
        mov dx,bx               ; y
        mov ah,0ch              ; ah = write pixel
        mov al,byte ptr cs:color

        mov bh, 0               ; page 0
        int 10h
        pop dx
        pop cx
        pop bx
        pop ax
        ret
pcpixel endp

_PC_curloc proc far
        push bp
        mov bp,sp
        mov dh, byte ptr [bp+X] ; row number
        mov dl, byte ptr [bp+X+2] ; col number
        mov bh, 0
        mov ah, 2
        int 10h
        pop bp
        ret
_PC_curloc endp

_PC_puts proc far
        push bp
        mov bp,sp
        mov ah,0eh              ; write TTY char
        mov bl,byte ptr cs:color
        mov es,[bp+X+2]         ; segment
        mov bp,[bp+X]           ; offset
puts2:  mov al,es:[bp]
        or al,al
        jz puts3
        int 10h
        inc bp
        jmp short puts2
puts3:  pop bp
        ret
_PC_puts endp

_prog   ends
        end
ov bp,sp
        push ax
        push bx
        push cx
        mov es,c
SHAR_EOF
echo shar: a missing newline was added to "'pcgraph.asm'"
if test 2618 -ne "`wc -c < 'pcgraph.asm'`"
then
        echo shar: error transmitting "'pcgraph.asm'" '(should have been 2618 characters)'
fi
chmod +x 'pcgraph.asm'
fi # end of overwriting check
echo shar: extracting "'plot.h'" '(4216 characters)'
if test -f 'plot.h'
then
        echo shar: will not over-write existing file "'plot.h'"
else
cat << \SHAR_EOF > 'plot.h'
/*
 *
 *    G N U P L O T  --  plot.h
 *
 *  Copyright (C) 1986 Colin Kelley, Thomas Williams
 *
 *  You may use this code as you wish if credit is given and this message
 *  is retained.
 *
 *  Please e-mail any useful additions to vu-vlsi!plot so they may be
 *  included in later releases.
 *
 *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
 */

#define PATCHLEVEL 0

#define PROGRAM "gnuplot"
#define PROMPT "gnuplot> "
#define SHELL "/bin/sh"
#ifdef vms
#define HELP  ""
#else /* vms */
#define HELP  "/usr/local/bin/help gnuplot"
#endif

#define TRUE 1
#define FALSE 0

#define Pi 3.141592653589793

#define MAX_PLOTS 9                     /* max number of overlapping plots */
#define MAX_LINE_LEN 255        /* maximum number of chars allowed on line */
#define MAX_TOKENS 200
#define MAX_ID_LEN 20           /* max length of an identifier */

#ifdef PC
#define MAX_UDFS 30                     /* max number of user-defined functions */
#else /* PC */
#define MAX_UDFS 100
#endif /* PC */

#define MAX_VALUES 50           /* max number of user-defined constants */
#define MAX_AT_LEN 100          /* max number of entries in action table */
#define STACK_DEPTH 100
#define NO_CARET (-1)

#define SAMPLES 160                     /* default number of samples for a plot */
#define ZERO    1e-8            /* default for 'zero' set option */

/*
 * note about HUGE:  this number is just used as a flag for really
 *   big numbers, so it doesn't have to be the absolutely biggest number
 *   on the machine.
 */

#ifdef PC
#define  HUGE 1e38
#endif /* PC */

#define END_OF_COMMAND (c_token == num_tokens || equals(c_token,";"))
#define push(arg) f_pushc(arg)  /* same thing! */

#define top_of_stack stack[s_p]

typedef int BOOLEAN;
typedef int (*FUNC_PTR)();

enum {
        C_PI, NEXT_VALUE
};

enum operators {
        PUSH, PUSHC, PUSHD, CALL, TERNIARY, LNOT, BNOT, UMINUS, LOR, LAND, BOR,
        XOR, BAND, EQ, NE, GT, LT, GE, LE, PLUS, MINUS, MULT, DIV, MOD, POWER,
        SF_START
};

enum DATA_TYPES {
        INT, CMPLX
};

enum PLOT_TYPES {
        FUNC, DATA
};

enum PLOT_STYLE {
        LINES, POINTS, IMPULSES
};

struct cmplx {
        double real, imag;
};

struct value {
        enum DATA_TYPES type;
        union {
                char *str_val;
                int int_val;
                struct cmplx cmplx_val;
        } v;
};

struct lexical_unit {
        BOOLEAN is_token;               /* true if token, false if a value */
        struct value l_val;
        int start_index;        /* index of first char in token */
        int length;             /* length of token in chars */
};

struct at_entry {               /* action table entry */
        int index;              /* index into function table */
        struct value arg;
};

struct at_type {
        int count;
        struct at_entry actions[MAX_AT_LEN];
};

struct ft_entry {               /* standard function table entry */
        char *ft_name;          /* pointer to name of this function */
        FUNC_PTR funct;         /* address of function to call */
};

struct udft_entry {             /* user-defined function table entry */
        char udft_name[MAX_ID_LEN+1];/* name of this function entry */
        struct at_type at;      /* action table to execute */
        char definition[MAX_LINE_LEN+1]; /* definition of function as typed */
        struct value dummy_value;/* current value of dummy variable */
};

struct vt_entry {               /* value table entry */
        char vt_name[MAX_ID_LEN+1];/* name of this value entry */
        BOOLEAN vt_undef;               /* true if not defined yet */
        struct value vt_value;  /* value it has */
};

struct coordinate {
        BOOLEAN undefined;      /* TRUE if value off screen */
#ifdef PC
        float x, y;                     /* memory is tight on PCs! */
#else
        double x, y;
#endif /* PC */
};

struct curve_points {
        enum PLOT_TYPES plot_type;
        enum PLOT_STYLE plot_style;
        char title[MAX_LINE_LEN + 1];
        int count;
        struct coordinate *points;
};

struct termentry {
        char name[MAX_ID_LEN + 1];
        unsigned int xmax,ymax,v_char,h_char,v_tic,h_tic;
        FUNC_PTR init,reset,text,graphics,move,vector,linetype,lrput_text,
                ulput_text,point;
};

/*
 * SS$_NORMAL is "normal completion", STS$M_INHIB_MSG supresses
 * printing a status message.
 * SS$_ABORT is the general abort status code.
 from:  Martin Minow
        decvax!minow
 */
#ifdef  vms
#include                <ssdef.h>
#include                <stsdef.h>
#define IO_SUCCESS      (SS$_NORMAL | STS$M_INHIB_MSG)
#define IO_ERROR        SS$_ABORT
#endif /* vms */

#ifndef IO_SUCCESS      /* DECUS or VMS C will have defined these already */
#define IO_SUCCESS      0
#endif
#ifndef IO_ERROR
#define IO_ERROR        1
#endif
SHAR_EOF
if test 4216 -ne "`wc -c < 'plot.h'`"
then
        echo shar: error transmitting "'plot.h'" '(should have been 4216 characters)'
fi
chmod +x 'plot.h'
fi # end of overwriting check
echo shar: extracting "'vmshelp.csh'" '(500 characters)'
if test -f 'vmshelp.csh'
then
        echo shar: will not over-write existing file "'vmshelp.csh'"
else
cat << \SHAR_EOF > 'vmshelp.csh'
#! /bin/csh
#
# vmshelp.csh /usr/help/gnuplot/* > gnuplot.hlp
# will convert the Unix help tree to VMS format,
# then use $ LIB/HELP GNUPLOT GNUPLOT under VMS to create the VMS .HLB

if (! $?level) then
        setenv level 0
endif
@ leveltmp = ($level + 1)
setenv level $leveltmp

foreach i ($*)
        if (-f $i) then
# plain file
                echo -n "$level "
                basename $i .HLP
                sed 's/^/ /' $i
        else if (-d $i) then
# directory
                echo -n "$level "
                basename $i
                sed 's/^/ /' $i/.HLP
# recurse!
                $0 $i/*
        endif
end
SHAR_EOF
if test 500 -ne "`wc -c < 'vmshelp.csh'`"
then
        echo shar: error transmitting "'vmshelp.csh'" '(should have been 500 characters)'
fi
chmod +x 'vmshelp.csh'
fi # end of overwriting check
echo shar: extracting "'simple.demo'" '(488 characters)'
if test -f 'simple.demo'
then
        echo shar: will not over-write existing file "'simple.demo'"
else
cat << \SHAR_EOF > 'simple.demo'
set samples 50
plot [-10:10] sin(x),atan(x),cos(atan(x))
set samples 100
plot [-pi/2:pi] cos(x),-(sin(x) > sin(x+1) ? sin(x) : sin(x+1))
set samples 200
plot [-3:5] asin(x),acos(x)
plot [-30:20] besj0(x)*0.12e1 with impulses, (x**besj0(x))-2.5 with points
set samples 400
plot [-10:10] real(sin(x)**besj0(x))
plot [-5*pi:5*pi] [-5:5] real(tan(x)/atan(x)), 1/x
set autoscale
set samples 800
plot [-30:20] sin(x*20)*atan(x)
plot [-19:19] '1.dat'with impulses ,'2.dat' ,'3.dat' with lines
SHAR_EOF
if test 488 -ne "`wc -c < 'simple.demo'`"
then
        echo shar: error transmitting "'simple.demo'" '(should have been 488 characters)'
fi
chmod +x 'simple.demo'
fi # end of overwriting check
echo shar: extracting "'1.dat'" '(781 characters)'
if test -f '1.dat'
then
        echo shar: will not over-write existing file "'1.dat'"
else
cat << \SHAR_EOF > '1.dat'
-20.000000 -3.041676
-19.000000 -3.036427
-18.000000 -3.030596
-17.000000 -3.024081
-16.000000 -3.016755
-15.000000 -3.008456
-14.000000 -2.998978
-13.000000 -2.988049
-12.000000 -2.975310
-11.000000 -2.960273
-10.000000 -2.942255
-9.000000 -2.920278
-8.000000 -2.892883
-7.000000 -2.857799
-6.000000 -2.811295
-5.000000 -2.746802
-4.000000 -2.651635
-3.000000 -2.498092
-2.000000 -2.214297
-1.000000 -1.570796
0.000000 0.000000
1.000000 1.570796
2.000000 2.214297
3.000000 2.498092
4.000000 2.651635
5.000000 2.746802
6.000000 2.811295
7.000000 2.857799
8.000000 2.892883
9.000000 2.920278
10.000000 2.942255
11.000000 2.960273
12.000000 2.975310
13.000000 2.988049
14.000000 2.998978
15.000000 3.008456
16.000000 3.016755
17.000000 3.024081
18.000000 3.030596
19.000000 3.036427
SHAR_EOF
if test 781 -ne "`wc -c < '1.dat'`"
then
        echo shar: error transmitting "'1.dat'" '(should have been 781 characters)'
fi
chmod +x '1.dat'
fi # end of overwriting check
echo shar: extracting "'2.dat'" '(781 characters)'
if test -f '2.dat'
then
        echo shar: will not over-write existing file "'2.dat'"
else
cat << \SHAR_EOF > '2.dat'
-20.000000 -6.083352
-19.000000 -6.072853
-18.000000 -6.061191
-17.000000 -6.048162
-16.000000 -6.033510
-15.000000 -6.016913
-14.000000 -5.997955
-13.000000 -5.976098
-12.000000 -5.950620
-11.000000 -5.920546
-10.000000 -5.884511
-9.000000 -5.840556
-8.000000 -5.785765
-7.000000 -5.715597
-6.000000 -5.622591
-5.000000 -5.493603
-4.000000 -5.303271
-3.000000 -4.996183
-2.000000 -4.428595
-1.000000 -3.141593
0.000000 0.000000
1.000000 3.141593
2.000000 4.428595
3.000000 4.996183
4.000000 5.303271
5.000000 5.493603
6.000000 5.622591
7.000000 5.715597
8.000000 5.785765
9.000000 5.840556
10.000000 5.884511
11.000000 5.920546
12.000000 5.950620
13.000000 5.976098
14.000000 5.997955
15.000000 6.016913
16.000000 6.033510
17.000000 6.048162
18.000000 6.061191
19.000000 6.072853
SHAR_EOF
if test 781 -ne "`wc -c < '2.dat'`"
then
        echo shar: error transmitting "'2.dat'" '(should have been 781 characters)'
fi
chmod +x '2.dat'
fi # end of overwriting check
echo shar: extracting "'3.dat'" '(781 characters)'
if test -f '3.dat'
then
        echo shar: will not over-write existing file "'3.dat'"
else
cat << \SHAR_EOF > '3.dat'
-20.000000 -9.125028
-19.000000 -9.109280
-18.000000 -9.091787
-17.000000 -9.072243
-16.000000 -9.050265
-15.000000 -9.025369
-14.000000 -8.996933
-13.000000 -8.964147
-12.000000 -8.925931
-11.000000 -8.880819
-10.000000 -8.826766
-9.000000 -8.760835
-8.000000 -8.678648
-7.000000 -8.573396
-6.000000 -8.433886
-5.000000 -8.240405
-4.000000 -7.954906
-3.000000 -7.494275
-2.000000 -6.642892
-1.000000 -4.712389
0.000000 0.000000
1.000000 4.712389
2.000000 6.642892
3.000000 7.494275
4.000000 7.954906
5.000000 8.240405
6.000000 8.433886
7.000000 8.573396
8.000000 8.678648
9.000000 8.760835
10.000000 8.826766
11.000000 8.880819
12.000000 8.925931
13.000000 8.964147
14.000000 8.996933
15.000000 9.025369
16.000000 9.050265
17.000000 9.072243
18.000000 9.091787
19.000000 9.109280
SHAR_EOF
if test 781 -ne "`wc -c < '3.dat'`"
then
        echo shar: error transmitting "'3.dat'" '(should have been 781 characters)'
fi
chmod +x '3.dat'
fi # end of overwriting check
#       End of shell archive
exit 0
